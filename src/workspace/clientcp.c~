/*
 *			C L I E N T C P
 *
 *	This is an example program that demonstrates the use of
 *	stream sockets as an IPC mechanism.  This contains the client,
 *	and is intended to operate in conjunction with the server
 *	program.  Together, these two programs
 *	demonstrate many of the features of sockets, as well as good
 *	conventions for using these features.
 *
 *
 */
 
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <string.h>
#include <time.h>
#include "tftp.h"

#define PUERTO 17278
#define TAM_BUFFER 1024

/*
 *			M A I N
 *
 *	This routine is the client which request service from the remote.
 *	It creates a connection, sends a number of
 *	requests, shuts down the connection in one direction to signal the
 *	server about the end of data, and then receives all of the responses.
 *	Status will be written to stdout.
 *
 *	The name of the system to which the requests will be sent is given
 *	as a parameter to the command.
 */
int main(argc, argv)
int argc;
char *argv[];
{
    int s;				/* connected socket descriptor */
   	struct addrinfo hints, *res;
    long timevar;			/* contains time returned by time() */
    struct sockaddr_in myaddr_in;	/* for local socket address */
    struct sockaddr_in servaddr_in;	/* for server socket address */
	int addrlen, i, j, errcode;
    /* This example uses TAM_BUFFER byte messages. */
	char buf[TAM_BUFFER];
	int eof_flag;
	
	/* VARIABLES UTILIZADAS POR NOSOTROS */
	
	char rfilename[] = "thisispdf.txt"; /* Esto luego será argv[4] */
	char wfilename[] = "fichero1.txt";  /* Esto luego será argv[4] */
	int nwrittenbytes = 0; /* Keeps the number of bytes written in a file */
	int nreadbytes = 0; /* Keeps the number of bytes read from file */
	char str[1000];
	short msg_type = 0;
	int tcp_mode = -1; /* Esto luego será argv[3] */
        int last_block = -1;
	FILE *ptr = NULL;
	// Mensajes de emisión
	rw_msg_t *rw_msg = NULL;
	ack_msg_t *ack_msg = NULL;
	data_msg_t *data_msg_rcv = NULL;
	// Mensajes de recepción
	data_msg_t data_msg;
	ack_msg_t ack_msg_rcv;

	if (argc == 1) { // clientcp localhost [r|w]
		fprintf(stderr, "Usage:  %s <remote host><[r|w] request>\n", argv[0]);
		exit(1);
	} else if (argc == 2) {
		fprintf(stderr, "Usage:  %s %s <[r|w] request>\n", argv[0], argv[1]);
		exit(1);
	} else if (argc == 3) {
		tcp_mode = WRITE_TYPE; //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Lo tengo por defecto puesto en modo lectura
/*
		if (strcmp(argv[2],"r")){
			tcp_mode = READ_TYPE;
			fprintf(stderr, "Seleccionado modo R");
		} else if (strcmp(argv[2],"w")){
			tcp_mode = WRITE_TYPE;
			fprintf(stderr, "Seleccionado modo W");
		}
*/
	}

	/* Create the socket. */
	s = socket (AF_INET, SOCK_STREAM, 0);
	if (s == -1) {
		perror(argv[0]);
		fprintf(stderr, "%s: unable to create socket\n", argv[0]);
		exit(1);
	}
	
	/* clear out address structures */
	memset ((char *)&myaddr_in, 0, sizeof(struct sockaddr_in));
	memset ((char *)&servaddr_in, 0, sizeof(struct sockaddr_in));

	/* Set up the peer address to which we will connect. */
	servaddr_in.sin_family = AF_INET;
	
	/* Get the host information for the hostname that the
	 * user passed in. */
      memset (&hints, 0, sizeof (hints));
      hints.ai_family = AF_INET;
 	 /* esta función es la recomendada para la compatibilidad con IPv6 gethostbyname queda obsoleta*/
    errcode = getaddrinfo (argv[1], NULL, &hints, &res); 
    if (errcode != 0){
			/* Name was not found.  Return a
			 * special value signifying the error. */
		fprintf(stderr, "%s: No es posible resolver la IP de %s\n",
				argv[0], argv[1]);
		exit(1);
        }
    else {
		/* Copy address of host */
		servaddr_in.sin_addr = ((struct sockaddr_in *) res->ai_addr)->sin_addr;
	    }
    freeaddrinfo(res);

    /* puerto del servidor en orden de red*/
	servaddr_in.sin_port = htons(PUERTO);

		/* Try to connect to the remote server at the address
		 * which was just built into peeraddr.
		 */
	if (connect(s, (const struct sockaddr *)&servaddr_in, sizeof(struct sockaddr_in)) == -1) {
		perror(argv[0]);
		fprintf(stderr, "%s: unable to connect to remote\n", argv[0]);
		exit(1);
	}
		/* Since the connect call assigns a free address
		 * to the local end of this connection, let's use
		 * getsockname to see what it assigned.  Note that
		 * addrlen needs to be passed in as a pointer,
		 * because getsockname returns the actual length
		 * of the address.
		 */
	addrlen = sizeof(struct sockaddr_in);
	if (getsockname(s, (struct sockaddr *)&myaddr_in, &addrlen) == -1) {
		perror(argv[0]);
		fprintf(stderr, "%s: unable to read socket address\n", argv[0]);
		exit(1);
	 }

	/* Print out a startup message for the user. */
	time(&timevar);
	/* The port number must be converted first to host byte
	 * order before printing.  On most hosts, this is not
	 * necessary, but the ntohs() call is included here so
	 * that this program could easily be ported to a host
	 * that does require it.
	 */
	printf("Connected to %s on port %u at %s",
			argv[1], ntohs(myaddr_in.sin_port), (char *) ctime(&timevar));


    // R/W Request
    
    eof_flag = 0;
    
    if (tcp_mode == READ_TYPE){
    	rw_msg = create_rw_msg(READ_TYPE, rfilename);
    } else if (tcp_mode == WRITE_TYPE) {
	    rw_msg = create_rw_msg(WRITE_TYPE, wfilename);
	}

    memcpy((void *)buf, (const void *)rw_msg, sizeof(*rw_msg));

    if (send(s, buf, TAM_BUFFER, 0) != TAM_BUFFER) {
		fprintf(stderr, "%s: Connection aborted on error ",	argv[0]);
		fprintf(stderr, "on send number %d\n", i);
		exit(1);
	}
    
    /*
	for (i = 1; i <= 5; i++) {
		*buf = i;
		if (send(s, buf, TAM_BUFFER, 0) != TAM_BUFFER) {
			fprintf(stderr, "%s: Connection aborted on error ",	argv[0]);
			fprintf(stderr, "on send number %d\n", i);
			exit(1);
		}
	}
    */
		/* Now, shutdown the connection for further sends.
		 * This will cause the server to receive an end-of-file
		 * condition after it has received all the requests that
		 * have just been sent, indicating that we will not be
		 * sending any further requests.
		 */
/*
	if (shutdown(s, 1) == -1) {
		perror(argv[0]);
		fprintf(stderr, "%s: unable to shutdown socket\n", argv[0]);
		exit(1);
	}
*/
		/* Now, start receiving all of the replys from the server.
		 * This loop will terminate when the recv returns zero,
		 * which is an end-of-file condition.  This will happen
		 * after the server has sent all of its replies, and closed
		 * its end of the connection.
		 */

	while (i = recv(s, buf, TAM_BUFFER, 0)) {
		if (i == -1) {
            perror(argv[0]);
			fprintf(stderr, "%s: error reading result\n", argv[0]);
			exit(1);
		}
			 
	    
		while (i < TAM_BUFFER) {
			j = recv(s, &buf[i], TAM_BUFFER-i, 0);
			if (j == -1) {
                     	     perror(argv[0]);
			     fprintf(stderr, "%s: error reading result\n", argv[0]);
			     exit(1);
               		}
			i += j;
		}
		
		fprintf(stderr,"VOY A RECIBIR DESDE CLIENTE\n");
		msg_type = *buf;
		fprintf(stderr,"EN CLIENTE %d\n",msg_type);

		switch(msg_type) {
		case ACK_TYPE:
		    fprintf(stderr,"EN ACK_TYPE\n");
		    memcpy((void *)&ack_msg_rcv, (const void *)&buf, sizeof(ack_msg));		
	
		    /*
		     * Para el ACK X:
		     *      1- Enviar bloque X + 1
		     */

		     data_msg_rcv = create_data_msg(ack_msg_rcv.n_block + 1);

		     if ((ptr = fopen(rfilename, "r")) == NULL) {
		        fprintf(stderr,"cliente.c: ACK_TYPE: could not open file to read: %s ", rfilename);
		        return -1;
		     }
		     
		     if (0 != fseek(ptr, nreadbytes, SEEK_SET)) {
		        fprintf(stderr,"cliente.c: ACK_TYPE: error in fseek");
		        return -1;
		     }
		     
		     if (1 != fread((void *)&(data_msg_rcv->data), sizeof(data_msg_rcv->data), 1, ptr)){
                if (ferror(ptr)) {
                    fprintf(stderr,"cliente.c: ACK_TYPE: error in fread");
                    return -1;
                } else if (feof(ptr)) {
                    fprintf(stderr,"Reached END OF FILE\n");
                    eof_flag = 1;
                }
		     }
		     
		     if (0 != fclose(ptr)){
		         fprintf(stderr,"cliente.c: ACK_TYPE: error in fclose");
	             	 return -1;
		     }
		     
		     ptr = NULL;
		     
		     printf("Received ACK number %d\n", ack_msg_rcv.n_block);

		     memcpy((void *)buf, (const void *)data_msg_rcv, sizeof(*data_msg_rcv));

		     nreadbytes += TFTP_DATA_SIZE;

		     if (send(s, buf, TAM_BUFFER, 0) != TAM_BUFFER){
		        printf("clientcp.c: ACK_TYPE: error in send\n");
	                return -1;
		     }
		     
		     if (eof_flag){
		        // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< TODO: End of transmission
		     }

		
		break;
		case DATA_TYPE:
		    fprintf(stderr,"EN DATA_TYPE\n");
		    memcpy((void *)&data_msg, (const void *)&buf, sizeof(data_msg));
		
		    /*
		     * Para el bloque X
		     *      1- Escribir DATA X
		     *      2- Mandar ACK (n = X)
		     */
		     
		     if ((ptr = fopen(wfilename, "a")) == NULL) {
		        printf("clientcp.c: DATA_TYPE: could not open file to read\n");
		        return -1;
		     }
		     
		     if (0 != fseek(ptr, nwrittenbytes, SEEK_SET)) {
		        printf("clientcp.c: DATA_TYPE: error in fseek\n");
		        return -1;
		     }
		     
		     if (1 != fwrite((void *)&(data_msg.data), sizeof(data_msg.data), 1, ptr)){
	             	printf("clientcp.c: DATA_TYPE: error in fwrite\n");
	             	return -1;
		     }

		     if (0 != fclose(ptr)){
		         printf("clientcp.c: DATA_TYPE: error in fclose\n");
	             	 return -1;
		     }
        	     ptr = NULL;
		     
		     printf("Received block number %d\n", data_msg.n_block);
		     
		     ack_msg = create_ack_msg(data_msg.n_block);

		     memcpy((void *)buf, (const void *)ack_msg, sizeof(*ack_msg));

		     nwrittenbytes += TFTP_DATA_SIZE;

		     if (send(s, buf, TAM_BUFFER, 0) != TAM_BUFFER){
		        printf("clientcp.c: DATA_TYPE: error in send\n");
	                return -1;
		     }

		break;
		case ERROR_TYPE:
		
		    /*
		     * Basicamente, finalizar la conexion
		     */
		     
		break;
		default:
		    printf("clientcp: Invalid type of message\n");
		    return -1;
		break;
		}
		
			/* Print out message indicating the identity of this reply. */
		//printf("Received result number %d\n", *buf);
	}

    /* Print message indicating completion of task. */
	time(&timevar);
	printf("All done at %s", (char *) ctime(&timevar));
}
